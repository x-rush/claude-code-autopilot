---
description: 智能上下文刷新 - 基于结构定义的纯插件实现
---

# /autopilot-context-refresh
智能上下文刷新功能 - 基于结构定义文件和运行时状态，帮助Claude Code在长时间执行过程中管理对话上下文，避免窗口限制，确保24小时无人值守执行的连续性。

## 🎯 上下文管理约束

**严格遵循结构定义驱动**：
- **基于结构定义验证**：使用 [`templates/`](templates/) 中的结构定义文件验证状态数据
- **纯插件读取**：Claude Code直接读取JSON状态文件，无外部依赖
- **智能信息提取**：从所有状态文件中提取关键信息进行上下文重构
- **需求对齐维持**：确保刷新后保持与原始需求的完全对齐
- **执行连续性保证**：刷新过程不影响执行的连续性和一致性

## 📋 上下文刷新挑战

### 1. 长时间执行的上下文限制
在24小时连续执行过程中，Claude Code面临：
- **上下文窗口限制**：长时间对话超出上下文窗口容量
- **关键信息丢失**：早期的重要决策和状态信息被遗忘
- **执行连续性中断**：新对话无法获取完整的执行历史
- **状态不一致风险**：上下文丢失可能导致执行偏差

### 2. 智能刷新的必要条件
为了实现真正的无人值守执行，需要：
- **自动信息提取**：从状态文件中智能提取关键信息
- **执行状态精确总结**：生成当前执行位置的精确描述
- **需求对齐重申**：确保刷新后保持原始需求对齐
- **执行计划同步**：同步当前执行计划和下一步行动

## 🔄 上下文刷新流程

### 1. 结构定义验证
```javascript
// Claude Code内部处理流程
首先验证templates/目录中的结构定义文件：
1. 读取 templates/EXECUTION_STATE.json 验证执行状态结构
2. 读取 templates/TODO_TRACKER.json 验证任务跟踪结构
3. 读取 templates/DECISION_LOG.json 验证决策记录结构
4. 读取 templates/REQUIREMENT_ALIGNMENT.json 验证需求对齐结构
5. 读取 templates/EXECUTION_PLAN.json 验证执行计划结构
```

### 2. 运行时状态收集
```javascript
// 检查和读取运行时状态文件
读取以下运行时生成的JSON状态文件：
- REQUIREMENT_ALIGNMENT.json（项目特定的需求对齐文件）
- EXECUTION_PLAN.json（项目特定的执行计划文件）
- TODO_TRACKER.json（当前任务进度状态）
- DECISION_LOG.json（决策记录和历史）
- EXECUTION_STATE.json（当前执行状态和会话信息）
```

### 3. 数据完整性验证
```javascript
// 基于结构定义验证数据完整性
1. 验证每个JSON文件符合对应的结构定义
2. 检查必需字段是否存在且类型正确
3. 验证文件间的数据关联性和一致性
4. 确认时间戳和ID的逻辑正确性
```

## 🧠 智能信息提取

### 1. 核心需求信息提取
从 REQUIREMENT_ALIGNMENT.json 提取：
```javascript
提取关键需求信息：
1. 用户原始任务：完整记录的原始需求描述
2. 核心目标结构：主要目标和成功标准
3. 分析需求结构：功能性和非功能性需求
4. 用户偏好设置：工作方式偏好和风险容忍度
5. 预设决策配置：已确认的技术决策和方案
```

### 2. 当前执行状态提取
从相关状态文件提取：
```javascript
提取当前执行信息：
1. 整体进度：任务完成百分比和当前阶段
2. 当前任务：正在执行的任务ID和详细状态
3. 已完成成果：重要交付物和质量评分
4. 执行效率：时间使用情况和效率分析
5. 系统健康：整体健康状态和趋势
```

### 3. 重要决策历史提取
从 DECISION_LOG.json 提取：
```javascript
提取决策相关信息：
1. 决策统计：总决策数和类型分布
2. 关键决策：重要的技术和执行决策
3. 偏离记录：偏离规划的决策和原因
4. 决策质量：决策的合理性和执行效果
5. 学习改进：基于决策的经验和改进方向
```

### 4. 下一步执行计划提取
从 EXECUTION_PLAN.json 和 TODO_TRACKER.json 提取：
```javascript
提取执行计划信息：
1. 下一个任务：即将执行的任务详情
2. 执行策略：采用的执行方法和质量门禁
3. 预期结果：下一步的预期完成标准
4. 时间预估：基于历史数据的时间预估
5. 风险预警：可能遇到的问题和预防措施
```

## 📊 上下文重构生成

### 1. 执行历史总结
```javascript
// 生成精简的执行历史
生成包含以下内容的总结：
1. 重要里程碑：按时间顺序的关键事件
2. 决策节点：重要决策点和选择理由
3. 成果记录：已完成的重要交付物
4. 质量轨迹：质量评分的变化趋势
5. 问题解决：遇到的问题和解决方案
```

### 2. 当前状态快照
```javascript
// 生成精确的当前状态
生成包含以下信息的快照：
1. 执行位置：精确的当前任务和进度
2. 成果价值：已完成工作的价值总结
3. 质量状态：当前质量评分和健康状况
4. 资源状态：系统资源和上下文健康度
5. 风险状态：当前风险和预警信息
```

### 3. 需求对齐重申
```javascript
// 重申原始需求对齐
确保以下需求对齐信息：
1. 核心目标：用户的主要目标和期望
2. 质量标准：确认的质量要求和标准
3. 技术方案：已确认的技术选择和架构
4. 约束条件：重要的技术约束和限制
5. 偏好设置：用户的工作方式和风险偏好
```

### 4. 下一步行动指南
```javascript
// 生成具体的执行指南
提供以下执行指导：
1. 立即行动：明确的下一步执行任务
2. 质量要求：任务执行的质量注意事项
3. 验收标准：任务完成的具体标准
4. 风险预防：已知风险的预防措施
5. 应急方案：异常情况的处理方案
```

## 🔗 上下文刷新报告模板

### 标准刷新报告格式
```markdown
## 上下文刷新报告
**生成时间**: [ISO_TIMESTAMP]
**会话ID**: [SESSION_ID]
**刷新原因**: [自动/手动触发]
**上下文健康度**: [健康评分]/10

### 原始需求摘要
**核心目标**: [用户主要目标的精简描述]
**关键交付物**: [重要交付物列表]
**质量标准**: [核心质量要求]
**技术约束**: [关键技术约束]
**用户偏好**: [重要的工作方式偏好]

### 当前执行状态
**总体进度**: [完成百分比]% ([已完成]/[总数])
**当前任务**: [当前任务ID] - [任务标题]
**执行阶段**: [当前阶段名称]
**质量评分**: [当前质量评分]
**系统健康**: [健康状态和趋势]

### 重要决策回顾
**技术决策**: [关键技术选择和理由]
**执行决策**: [重要执行策略]
**质量决策**: [质量相关的决策]
**偏离记录**: [重要偏离和应对]

### 已完成成果
**交付物**: [已完成的重要交付物]
**质量状况**: [质量指标和评分]
**需求对齐**: [与原始需求的对齐状态]
**经验总结**: [重要经验和改进]

### 下一步执行指南
**立即行动**: [下一步具体执行任务]
**质量要求**: [质量注意事项和标准]
**验收标准**: [明确的完成标准]
**时间预估**: [预估完成时间]
**风险预警**: [潜在风险和预防措施]

### 重要提醒
- [基于当前状态的关键提醒1]
- [需要特别注意的事项]
- [需求对齐的重要注意事项]

**执行约束**: 严格按照以上信息继续执行，保持与原始需求的完全对齐。
```

## ⚙️ 使用方法

### 自动上下文刷新
```bash
/autopilot-context-refresh
```
执行完整的上下文刷新：
1. 验证所有状态文件的完整性和一致性
2. 从状态文件中智能提取关键信息
3. 生成精简但完整的上下文重构
4. 确保需求对齐和执行连续性
5. 提供明确的下一步执行指导

### 验证刷新效果
```bash
/autopilot-context-refresh --verify
```
验证刷新效果：
1. 检查刷新后信息的完整性
2. 验证执行连续性是否保持
3. 确认需求对齐状态是否正常
4. 评估上下文健康度改善情况

### 强制完整刷新
```bash
/autopilot-context-refresh --full
```
执行完整的深度刷新：
1. 重新验证所有结构定义文件
2. 完整重建所有状态文件的缓存
3. 生成最详细的上下文重构
4. 提供全面的执行状态报告

## 📝 注意事项

### 结构定义驱动
- 所有状态验证都基于templates/中的结构定义
- 确保运行时数据符合预期的数据结构
- 刷新过程保持数据结构的一致性

### 纯插件实现
- 完全由Claude Code自主执行上下文刷新
- 不依赖任何外部脚本或监控工具
- 直接读取和解析JSON状态文件

### 智能刷新策略
- 基于状态文件内容智能判断刷新需求
- 提取最关键的信息进行上下文重构
- 确保刷新后执行质量和连续性

### 需求对齐保证
- 刷新过程始终保持与原始需求的对齐
- 重新确认核心目标和质量标准
- 确保执行方向不偏离用户期望

---

现在开始执行上下文刷新。我将基于结构定义文件验证运行时状态，生成智能的上下文重构，确保24小时连续执行的连续性。

## 📋 生成内容模板

### 上下文刷新报告
```
## 上下文刷新报告
生成时间：[当前时间戳]
会话ID：[原始会话ID]
执行阶段：[当前执行阶段]

### 原始需求摘要
**核心目标**：[用户的主要目标]
**关键交付物**：[重要交付物列表]
**质量标准**：[质量要求摘要]
**特殊约束**：[重要约束条件]

### 当前执行状态
**总体进度**：[完成百分比] ([已完成数]/[总数])
**当前任务**：[当前正在执行的任务]
**任务状态**：[正常/延迟/异常]
**下一任务**：[即将执行的任务]

### 重要决策回顾
**技术决策**：[重要技术选择和理由]
**执行决策**：[重要执行策略选择]
**质量决策**：[质量相关的决策]

### 执行成果总结
**已完成成果**：[重要成果列表]
**质量状况**：[当前质量评分]
**需求对齐**：[与原始需求的对齐状况]

### 下一步执行指南
**立即行动**：[下一步具体行动]
**质量要求**：[质量注意事项]
**预期结果**：[预期完成标准]
**时间预估**：[预估完成时间]

### 重要提醒
- [基于当前状态的重要提醒1]
- [基于当前状态的重要提醒2]
- [需要特别注意的事项]

基于以上信息，请继续执行当前任务，保持与原始需求的完全对齐。
```

## 🔧 自动刷新策略

### 刷新触发条件
上下文刷新在以下情况下自动触发：

1. **对话长度监控**：
   - 检测到对话接近上下文窗口限制
   - 预估剩余可用上下文空间
   - 在合适的时机主动触发刷新

2. **时间间隔触发**：
   - 每执行2小时自动刷新一次
   - 确保关键信息不会丢失
   - 保持执行状态的准确性

3. **重要节点触发**：
   - 完成重要里程碑后
   - 遇到复杂决策后
   - 发现执行偏差后

### 刷新效果验证
刷新后进行效果验证：

1. **信息完整性检查**：验证关键信息是否完整
2. **执行连续性检查**：确认执行是否能正常继续
3. **需求一致性检查**：验证与原始需求的一致性
4. **质量状态检查**：确认质量指标是否正常

## 🎯 使用场景

### 适用情况
此命令适用于以下场景：

1. **长时间执行**：执行时间超过2小时的复杂项目
2. **复杂决策**：包含大量技术决策的复杂任务
3. **质量要求高**：对质量一致性要求很高的项目
4. **需求复杂**：需求复杂且需要持续对齐的项目

### 配合使用
与以下命令配合使用效果更佳：

- `/autopilot-status` - 查看详细执行状态
- `/autopilot-continuous-start` - 启动连续执行
- `/autopilot-align` - 需求对齐检查

---

## 技术实现

### 自动化集成
此命令可以集成到智能助手中，实现：
- 自动检测上下文窗口使用情况
- 智能判断刷新时机
- 自动生成和发送刷新信息
- 验证刷新效果并调整策略

### 状态文件管理
确保状态文件的：
- 实时更新和同步
- 数据一致性和完整性
- 异常情况的恢复机制
- 版本控制和历史追踪

## 🤖 纯插件实现特点

### 智能刷新系统
此命令采用纯插件实现，提供完整的上下文管理：

1. **直接状态读取**
   - Claude Code直接读取JSON状态文件
   - 无需外部脚本或工具
   - 原生JSON解析能力

2. **智能信息提取**
   - 从所有状态文件中提取关键信息
   - 生成精简的执行摘要
   - 保持需求对齐信息

3. **自动刷新触发**
   - 基于对话长度智能判断
   - 关键节点自动刷新
   - 无需外部监控进程

4. **上下文健康度评估**
   - 监控上下文窗口使用率
   - 评估信息完整性
   - 调整刷新策略

### 纯插件优势
- **无外部依赖**: 完全依赖Claude Code原生能力
- **实时响应**: 基于对话状态即时触发
- **智能判断**: AI驱动的刷新时机判断
- **质量维持**: 刷新后保持与原始需求的一致性

---

## 🚀 使用方法

### 自动刷新（推荐）
```bash
/autopilot-context-refresh
```

### 手动触发刷新
如需手动控制刷新时机：

1. **仅刷新上下文**
   ```bash
   /autopilot-context-refresh
   ```

2. **验证刷新效果**
   ```bash
   /autopilot-status  # 检查刷新后状态
   ```

3. **检查需求对齐**
   ```bash
   /autopilot-align    # 验证需求对齐状态
   ```

### 刷新触发时机
建议在以下情况下手动刷新：
- **对话较长时**: 感觉上下文可能丢失关键信息
- **重要节点后**: 完成重要里程碑或复杂决策
- **状态异常时**: 怀疑执行状态可能不一致
- **长时间执行**: 连续执行超过2小时后

---

## ⚡ 纯插件优势

**这是一个完全基于Claude Code原生能力的智能上下文管理系统**，能够：

1. **无外部依赖**: 完全依赖Claude Code的原生文件操作能力
2. **智能判断**: 基于AI的对话状态分析和刷新时机判断
3. **实时响应**: 基于对话状态即时触发，无需外部监控
4. **连续保证**: 确保24小时连续执行不受上下文限制影响
5. **质量维持**: 刷新过程中保持执行质量和需求对齐

**真正解决了长时间自主执行中的上下文窗口限制问题**，是24小时连续执行的关键技术保障，采用纯插件方案确保简单可靠。