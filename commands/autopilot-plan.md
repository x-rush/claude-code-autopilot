---
description: 基于需求对齐结果生成详细的执行计划和任务清单
---

# /autopilot-plan
基于已确认的需求对齐结果，读取 [`templates/EXECUTION_PLAN.json`](templates/EXECUTION_PLAN.json) 结构定义，动态生成项目特定的执行计划，确保24小时无人值守执行的可行性。

## 🎯 规划约束

**严格遵循需求对齐**：
- **基于需求对齐生成**：完全基于REQUIREMENT_ALIGNMENT.json中的用户需求和决策
- **任务可执行性**：确保每个任务都是具体、可执行、可验证的
- **依赖关系清晰**：明确定义任务间的依赖关系和执行顺序
- **质量门禁明确**：为每个任务设定清晰的质量标准和验收条件
- **自主执行友好**：生成的计划支持Claude Code自主执行和状态管理

## 📋 规划前检查

### 1. 验证需求对齐完整性
```javascript
// Claude Code内部处理流程
检查 REQUIREMENT_ALIGNMENT.json 是否包含：
- 完整的用户原始任务描述
- 已确认的功能性和非功能性需求
- 明确的技术约束和业务约束
- 详细的用户目标和成功标准
- 完整的交付物清单和优先级
- 已确定的预设决策和技术方案
```

### 2. 验证用户偏好
```javascript
检查执行偏好设置：
- 代码风格和详细程度偏好
- 测试方法和质量标准要求
- 文档风格和技术深度偏好
- 风险容忍度和错误处理方式
- 时间和范围的灵活性要求
```

### 3. 分析项目复杂性
```javascript
评估项目特征：
- 技术复杂度和创新程度
- 功能范围和实现难度
- 质量标准和性能要求
- 集成复杂度和依赖关系
```

## 🚀 执行计划生成

### 1. 读取结构定义
```javascript
// Claude Code内部处理流程
1. 读取 templates/EXECUTION_PLAN.json 获取完整数据结构
2. 理解每个字段的含义和约束条件
3. 基于需求对齐结果填充具体内容
4. 确保生成计划的完整性和一致性
```

### 2. 任务分解策略
基于需求对齐结果，我将：

#### 功能性任务分解
```javascript
// 基于functional_requirements生成任务
1. 将每个功能需求分解为具体实现任务
2. 按照技术架构分层组织任务
3. 确保任务粒度适中（1-4小时完成）
4. 明确每个任务的具体输入和输出
```

#### 非功能性任务分解
```javascript
// 基于non_functional_requirements生成任务
1. 性能优化任务
2. 安全检查和加固任务
3. 测试和质量保证任务
4. 文档和部署准备任务
```

#### 约束处理任务
```javascript
// 基于constraints生成特殊任务
1. 技术约束适配任务
2. 平台兼容性处理任务
3. 合规性和标准检查任务
4. 资源限制优化任务
```

### 3. 执行策略设定
基于用户偏好和项目特点，设定：

#### 执行方法
- **渐进式执行**：对于复杂项目，采用增量迭代方式
- **瀑布式执行**：对于需求明确的项目，采用线性执行方式
- **混合式执行**：结合两种方法的优势

#### 质量门禁
```javascript
// 基于quality_gates设定质量检查点
1. 代码质量检查：语法、风格、结构标准
2. 功能验证检查：单元测试、集成测试
3. 性能基准检查：响应时间、资源使用
4. 安全标准检查：漏洞扫描、权限验证
```

#### 自检间隔
- **自动自检**：每个任务完成后自动执行自检
- **定期自检**：每完成一定数量任务后进行深度检查
- **里程碑自检**：每个阶段完成后进行全面检查

### 4. 任务依赖关系设计
确保任务执行的逻辑性和连贯性：

#### 前置依赖
```javascript
// 定义任务间的依赖关系
1. 技术依赖：基础组件必须在应用组件之前完成
2. 逻辑依赖：需求分析必须在设计实现之前完成
3. 质量依赖：测试任务必须在开发任务之后完成
```

#### 并行执行
```javascript
// 识别可并行执行的任务
1. 独立模块开发：不同功能模块可以并行开发
2. 文档编写：开发过程中可以并行编写文档
3. 测试准备：开发早期可以并行准备测试环境
```

### 5. 预设决策配置
将需求对齐中的决策转化为执行指导：

#### 技术决策实施
```javascript
// 基于preset_decisions配置技术实施
1. 将确认的技术方案转化为具体实施步骤
2. 为备选方案设定触发条件和选择标准
3. 配置决策检查点和验证方法
4. 设定决策记录和跟踪机制
```

#### 偏好设置实施
```javascript
// 基于execution_preferences配置实施风格
1. 代码风格配置：格式规范、注释要求
2. 文档风格配置：详细程度、技术深度
3. 测试策略配置：测试类型、覆盖率要求
4. 质量标准配置：检查工具、评分标准
```

## 📊 执行计划结构

### 1. 会话信息
- 生成唯一的执行计划ID
- 记录基于的需求对齐ID
- 标记计划生成时间
- 估算总执行时长

### 2. 执行策略
- 明确执行方法（渐进式/瀑布式/混合式）
- 配置质量门禁检查策略
- 设定自检间隔和检查方法
- 定义偏离处理策略

### 3. 预设决策配置
- 技术决策的具体实施指导
- 内容决策的处理原则
- 执行决策的操作方法
- 备选方案的触发条件

### 4. 任务清单
为每个任务定义：
- 任务ID和标题描述
- 任务类型和分类
- 优先级和复杂度
- 预估执行时长
- 详细的验收标准
- 前置依赖关系
- 预期输出物
- 自检点配置
- 错误处理策略
- 质量要求配置
- 安全考虑事项

### 5. 执行阶段
将任务组织为逻辑阶段：
- 阶段ID和名称描述
- 起始任务和结束任务
- 阶段成功标准
- 阶段出口条件

### 6. 执行门禁
设定关键检查点：
- 门禁ID和名称
- 必需完成的任务列表
- 质量阈值要求
- 验证标准定义
- 自动通过条件

### 7. 安全边界
定义执行约束：
- 工作区根目录限制
- 允许和禁止的目录
- 允许和禁止的操作
- 文件大小和时间限制
- 最大操作数量限制

### 8. 上下文管理
配置Claude Code执行环境：
- 上下文刷新间隔
- 关键信息保留策略
- 检查点频率设置

### 9. 监控配置
设定执行监控：
- 进度更新频率
- 质量检查频率
- 日志记录级别
- 指标跟踪配置

### 10. 恢复策略
配置异常恢复：
- 检查点策略
- 备份频率设置
- 状态持久化配置
- 自动恢复启用
- 恢复尝试次数限制

### 11. 完成标准
定义成功标准：
- 所有任务完成状态
- 质量门禁通过状态
- 验收标准满足状态
- 文档完整性状态
- 需求对齐有效状态
- 最终质量评分阈值

## 🔍 计划验证

### 1. 完整性检查
```javascript
验证计划完整性：
1. 所有需求都有对应的实施任务
2. 任务依赖关系逻辑正确
3. 质量门禁覆盖所有关键点
4. 时间估算合理且有缓冲
5. 风险识别和应对措施完整
```

### 2. 可行性评估
```javascript
评估执行可行性：
1. 任务粒度适合自主执行
2. 依赖关系清晰可管理
3. 质量标准可验证
4. 资源需求在合理范围内
5. 风险控制措施有效
```

### 3. 需求对齐验证
```javascript
验证与需求的一致性：
1. 执行计划完全覆盖用户需求
2. 技术方案符合预设决策
3. 质量标准满足用户期望
4. 交付物清单完整对应
5. 约束条件得到妥善处理
```

## ⚙️ 使用方法

### 生成完整执行计划
```bash
/autopilot-plan
```
生成项目特定的执行计划：
1. 验证需求对齐文件完整性
2. 基于需求分解生成任务清单
3. 设定执行策略和质量门禁
4. 配置安全边界和恢复策略
5. 验证计划的完整性和可行性

### 更新执行计划
```bash
/autopilot-plan --update
```
更新现有执行计划：
- 基于新的需求对齐更新计划
- 调整任务分解或执行策略
- 重新验证计划的完整性

### 验证执行计划
```bash
/autopilot-plan --validate
```
验证当前执行计划：
- 检查计划的完整性和一致性
- 评估执行可行性
- 识别潜在风险和问题

## 📝 注意事项

### 动态生成特性
- 执行计划是基于需求对齐动态生成的
- 不是预置模板，而是需求分析的结果
- 每个项目都有独特的执行计划
- 计划内容完全反映用户的具体需求

### 24小时执行友好
- 任务粒度适合自动化执行
- 依赖关系清晰明确
- 质量标准可自动验证
- 异常处理和恢复策略完善
- 状态支持自主管理

### 需求驱动
- 所有任务都源于用户需求
- 执行策略体现用户偏好
- 质量标准反映用户期望
- 约束条件得到充分考虑

---

现在开始生成执行计划。我将验证需求对齐文件，然后基于你的具体需求生成项目特定的执行计划。